tvgCanvas.cpp:Canvas::Canvas(RenderMethod *pRenderer):pImpl(new Impl(pRenderer))
tvgCanvas.cpp:    delete(pImpl);
tvgCanvas.cpp:    pImpl->paints.reserve(n);
tvgCanvas.cpp:    return pImpl->push(move(paint));
tvgCanvas.cpp:    return pImpl->clear(free);
tvgCanvas.cpp:    return pImpl->draw();
tvgCanvas.cpp:    return pImpl->update(paint, false);
tvgCanvas.cpp:    if (pImpl->renderer->sync()) return Result::Success;
tvgCanvas.cpp:   return pImpl->load(path);
tvgCanvas.cpp:   return pImpl->load(data, size);
tvgCanvasImpl.h:                (*paint)->pImpl->dispose(*renderer);
tvgCanvasImpl.h:            paint->pImpl->update(*renderer, nullptr, 255, clips, flag);
tvgCanvasImpl.h:                (*paint)->pImpl->update(*renderer, nullptr, 255, clips, flag);
tvgCanvasImpl.h:            if (!(*paint)->pImpl->render(*renderer)) return Result::InsufficientCondition;
tvgFill.cpp:Fill::Fill():pImpl(new Impl())
tvgFill.cpp:    delete(pImpl);
tvgFill.cpp:        if (pImpl->colorStops) {
tvgFill.cpp:            free(pImpl->colorStops);
tvgFill.cpp:            pImpl->colorStops = nullptr;
tvgFill.cpp:            pImpl->cnt = cnt;
tvgFill.cpp:    if (pImpl->cnt != cnt) {
tvgFill.cpp:        pImpl->colorStops = static_cast<ColorStop*>(realloc(pImpl->colorStops, cnt * sizeof(ColorStop)));
tvgFill.cpp:    pImpl->cnt = cnt;
tvgFill.cpp:    memcpy(pImpl->colorStops, colorStops, cnt * sizeof(ColorStop));
tvgFill.cpp:    if (colorStops) *colorStops = pImpl->colorStops;
tvgFill.cpp:    return pImpl->cnt;
tvgFill.cpp:    pImpl->spread = s;
tvgFill.cpp:    return pImpl->spread;
tvgFill.cpp:    return pImpl->duplicate();
tvgFill.h:        ret->pImpl->cnt = cnt;
tvgFill.h:        ret->pImpl->spread = spread;
tvgFill.h:        ret->pImpl->colorStops = static_cast<ColorStop*>(malloc(sizeof(ColorStop) * cnt));
tvgFill.h:        memcpy(ret->pImpl->colorStops, colorStops, sizeof(ColorStop) * cnt);
tvgGlCanvas.cpp:GlCanvas::GlCanvas() : Canvas(GlRenderer::gen()), pImpl(new Impl)
tvgGlCanvas.cpp:GlCanvas::GlCanvas() : Canvas(nullptr), pImpl(new Impl)
tvgGlCanvas.cpp:    delete(pImpl);
tvgGlCanvas.cpp:    auto renderer = static_cast<GlRenderer*>(Canvas::pImpl->renderer);
tvgLinearGradient.cpp:        ret->pImpl->x1 = x1;
tvgLinearGradient.cpp:        ret->pImpl->y1 = y1;
tvgLinearGradient.cpp:        ret->pImpl->x2 = x2;
tvgLinearGradient.cpp:        ret->pImpl->y2 = y2;
tvgLinearGradient.cpp:LinearGradient::LinearGradient():pImpl(new Impl())
tvgLinearGradient.cpp:    Fill::pImpl->method(new FillDup<LinearGradient::Impl>(pImpl));
tvgLinearGradient.cpp:    delete(pImpl);
tvgLinearGradient.cpp:    pImpl->x1 = x1;
tvgLinearGradient.cpp:    pImpl->y1 = y1;
tvgLinearGradient.cpp:    pImpl->x2 = x2;
tvgLinearGradient.cpp:    pImpl->y2 = y2;
tvgLinearGradient.cpp:    if (x1) *x1 = pImpl->x1;
tvgLinearGradient.cpp:    if (x2) *x2 = pImpl->x2;
tvgLinearGradient.cpp:    if (y1) *y1 = pImpl->y1;
tvgLinearGradient.cpp:    if (y2) *y2 = pImpl->y2;
tvgPaint.cpp:Paint :: Paint() : pImpl(new Impl())
tvgPaint.cpp:    delete(pImpl);
tvgPaint.cpp:    if (pImpl->rotate(degree)) return Result::Success;
tvgPaint.cpp:    if (pImpl->scale(factor)) return Result::Success;
tvgPaint.cpp:    if (pImpl->translate(x, y)) return Result::Success;
tvgPaint.cpp:    if (pImpl->transform(m)) return Result::Success;
tvgPaint.cpp:    if (pImpl->bounds(x, y, w, h)) return Result::Success;
tvgPaint.cpp:    return pImpl->duplicate();
tvgPaint.cpp:    if (pImpl->composite(target.release(), method)) return Result::Success;
tvgPaint.cpp:    if (pImpl->opacity == o) return Result::Success;
tvgPaint.cpp:    pImpl->opacity = o;
tvgPaint.cpp:    pImpl->flag |= RenderUpdateFlag::Color;
tvgPaint.cpp:    return pImpl->opacity;
tvgPaint.cpp:   return pImpl->tvgLoad(pointer, end);
tvgPaint.cpp:   return pImpl->tvgStore();
tvgPaint.h:            if (cmpTarget) cmpTarget->pImpl->dispose(renderer);
tvgPaint.h:                cmpData = cmpTarget->pImpl->update(renderer, pTransform, 255, clips, pFlag);
tvgPaint.h:                if (!cmpTarget->pImpl->bounds(renderer, &x, &y, &w, &h)) return false;
tvgPaint.h:                cmpTarget->pImpl->render(renderer);
tvgPaint.h:            if (cmp) renderer.beginComposite(cmp, cmpMethod, cmpTarget->pImpl->opacity);
tvgPaint.h:                ret->pImpl->rTransform = new RenderTransform();
tvgPaint.h:                if (ret->pImpl->rTransform) {
tvgPaint.h:                    *ret->pImpl->rTransform = *rTransform;
tvgPaint.h:                    ret->pImpl->flag |= RenderUpdateFlag::Transform;
tvgPaint.h:            ret->pImpl->opacity = opacity;
tvgPaint.h:            if (cmpTarget) ret->pImpl->cmpTarget = cmpTarget->duplicate();
tvgPaint.h:            ret->pImpl->cmpMethod = cmpMethod;
tvgPicture.cpp:Picture::Picture() : pImpl(new Impl(this))
tvgPicture.cpp:    Paint::pImpl->method(new PaintMethod<Picture::Impl>(pImpl));
tvgPicture.cpp:    delete(pImpl);
tvgPicture.cpp:    return pImpl->load(path);
tvgPicture.cpp:    return pImpl->load(data, size);
tvgPicture.cpp:    return pImpl->load(data, w, h, copy);
tvgPicture.cpp:    if (pImpl->viewbox(x, y, w, h)) return Result::Success;
tvgPicture.cpp:    if (pImpl->size(w, h)) return Result::Success;
tvgPicture.cpp:    if (w) *w = pImpl->w;
tvgPicture.cpp:    if (h) *h = pImpl->h;
tvgPicture.cpp:    if (pImpl->loader) return pImpl->loader->pixels();
tvgPicture.cpp:    return pImpl->pixels;
tvgPictureImpl.h:            ret = paint->pImpl->dispose(renderer);
tvgPictureImpl.h:            rdata = paint->pImpl->update(renderer, transform, opacity, clips, static_cast<RenderUpdateFlag>(pFlag | flag));
tvgPictureImpl.h:        else if (paint) return paint->pImpl->render(renderer);
tvgPictureImpl.h:        return paint->pImpl->bounds(x, y, w, h);
tvgPictureImpl.h:        if (paint) return paint->pImpl->bounds(renderer, x, y, w, h);
tvgPictureImpl.h:        auto dup = ret.get()->pImpl;
tvgRadialGradient.cpp:        ret->pImpl->cx = cx;
tvgRadialGradient.cpp:        ret->pImpl->cy = cy;
tvgRadialGradient.cpp:        ret->pImpl->radius = radius;
tvgRadialGradient.cpp:RadialGradient::RadialGradient():pImpl(new Impl())
tvgRadialGradient.cpp:    Fill::pImpl->method(new FillDup<RadialGradient::Impl>(pImpl));
tvgRadialGradient.cpp:    delete(pImpl);
tvgRadialGradient.cpp:    pImpl->cx = cx;
tvgRadialGradient.cpp:    pImpl->cy = cy;
tvgRadialGradient.cpp:    pImpl->radius = radius;
tvgRadialGradient.cpp:    if (cx) *cx = pImpl->cx;
tvgRadialGradient.cpp:    if (cy) *cy = pImpl->cy;
tvgRadialGradient.cpp:    if (radius) *radius = pImpl->radius;
tvgSaver.h:    //void nic(Scene* scene) {cout << "UDALO SIE " << (int)scene->pImpl->opacity << endl;};
tvgSaver.h:       cout << "UDALO SIE " << (int)sc->pImpl->opacity << endl;
tvgScene.cpp:Scene::Scene() : pImpl(new Impl())
tvgScene.cpp:    Paint::pImpl->method(new PaintMethod<Scene::Impl>(pImpl));
tvgScene.cpp:    delete(pImpl);
tvgScene.cpp:    pImpl->paints.push(p);
tvgScene.cpp:    pImpl->paints.reserve(size);
tvgScene.cpp:    pImpl->paints.clear();
tvgScene.cpp:    //return pImpl->save(path);
tvgScene.cpp:    return pImpl->save(path, this); //MGS2
tvgScene.cpp:    pImpl->serializationStart();
tvgScene.cpp:   return pImpl->load(path);
tvgScene.cpp:   return pImpl->load(data, size);
tvgSceneImpl.h:            (*paint)->pImpl->dispose(renderer);
tvgSceneImpl.h:            (*paint)->pImpl->update(renderer, transform, opacity, clips, static_cast<uint32_t>(flag));
tvgSceneImpl.h:            if (!(*paint)->pImpl->render(renderer)) return false;
tvgSceneImpl.h:            if (!(*paint)->pImpl->bounds(renderer, &x, &y, &w, &h)) continue;
tvgSceneImpl.h:            if (!(*paint)->pImpl->bounds(&x, &y, &w, &h)) continue;
tvgSceneImpl.h:        auto dup = ret.get()->pImpl;
tvgSceneImpl.h:            (*paint)->pImpl->serialize(pointer);
tvgShape.cpp:Shape :: Shape() : pImpl(new Impl(this))
tvgShape.cpp:    Paint::pImpl->method(new PaintMethod<Shape::Impl>(pImpl));
tvgShape.cpp:    delete(pImpl);
tvgShape.cpp:    pImpl->reset();
tvgShape.cpp:    *cmds = pImpl->path.cmds;
tvgShape.cpp:    return pImpl->path.cmdCnt;
tvgShape.cpp:    *pts = pImpl->path.pts;
tvgShape.cpp:    return pImpl->path.ptsCnt;
tvgShape.cpp:    pImpl->path.grow(cmdCnt, ptsCnt);
tvgShape.cpp:    pImpl->path.append(cmds, cmdCnt, pts, ptsCnt);
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->path.moveTo(x, y);
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->path.lineTo(x, y);
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->path.cubicTo(cx1, cy1, cx2, cy2, x, y);
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->path.close();
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->path.grow(6, 13);
tvgShape.cpp:    pImpl->path.moveTo(cx, cy - ry);
tvgShape.cpp:    pImpl->path.cubicTo(cx + rxKappa, cy - ry, cx + rx, cy - ryKappa, cx + rx, cy);
tvgShape.cpp:    pImpl->path.cubicTo(cx + rx, cy + ryKappa, cx + rxKappa, cy + ry, cx, cy + ry);
tvgShape.cpp:    pImpl->path.cubicTo(cx - rxKappa, cy + ry, cx - rx, cy + ryKappa, cx - rx, cy);
tvgShape.cpp:    pImpl->path.cubicTo(cx - rx, cy - ryKappa, cx - rxKappa, cy - ry, cx, cy - ry);
tvgShape.cpp:    pImpl->path.close();
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:        pImpl->path.moveTo(cx, cy);
tvgShape.cpp:        pImpl->path.lineTo(start.x + cx, start.y + cy);
tvgShape.cpp:        pImpl->path.moveTo(start.x + cx, start.y + cy);
tvgShape.cpp:        pImpl->path.cubicTo(ctrl1.x, ctrl1.y, ctrl2.x, ctrl2.y, end.x, end.y);
tvgShape.cpp:    if (pie) pImpl->path.close();
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:        pImpl->path.grow(5, 4);
tvgShape.cpp:        pImpl->path.moveTo(x, y);
tvgShape.cpp:        pImpl->path.lineTo(x + w, y);
tvgShape.cpp:        pImpl->path.lineTo(x + w, y + h);
tvgShape.cpp:        pImpl->path.lineTo(x, y + h);
tvgShape.cpp:        pImpl->path.close();
tvgShape.cpp:        pImpl->path.grow(10, 17);
tvgShape.cpp:        pImpl->path.moveTo(x + rx, y);
tvgShape.cpp:        pImpl->path.lineTo(x + w - rx, y);
tvgShape.cpp:        pImpl->path.cubicTo(x + w - rx + hrx, y, x + w, y + ry - hry, x + w, y + ry);
tvgShape.cpp:        pImpl->path.lineTo(x + w, y + h - ry);
tvgShape.cpp:        pImpl->path.cubicTo(x + w, y + h - ry + hry, x + w - rx + hrx, y + h, x + w - rx, y + h);
tvgShape.cpp:        pImpl->path.lineTo(x + rx, y + h);
tvgShape.cpp:        pImpl->path.cubicTo(x + rx - hrx, y + h, x, y + h - ry + hry, x, y + h - ry);
tvgShape.cpp:        pImpl->path.lineTo(x, y + ry);
tvgShape.cpp:        pImpl->path.cubicTo(x, y + ry - hry, x + rx - hrx, y, x + rx, y);
tvgShape.cpp:        pImpl->path.close();
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Path;
tvgShape.cpp:    pImpl->color[0] = r;
tvgShape.cpp:    pImpl->color[1] = g;
tvgShape.cpp:    pImpl->color[2] = b;
tvgShape.cpp:    pImpl->color[3] = a;
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Color;
tvgShape.cpp:    if (pImpl->fill) {
tvgShape.cpp:        delete(pImpl->fill);
tvgShape.cpp:        pImpl->fill = nullptr;
tvgShape.cpp:        pImpl->flag |= RenderUpdateFlag::Gradient;
tvgShape.cpp:    if (pImpl->fill && pImpl->fill != p) delete(pImpl->fill);
tvgShape.cpp:    pImpl->fill = p;
tvgShape.cpp:    pImpl->flag |= RenderUpdateFlag::Gradient;
tvgShape.cpp:    if (r) *r = pImpl->color[0];
tvgShape.cpp:    if (g) *g = pImpl->color[1];
tvgShape.cpp:    if (b) *b = pImpl->color[2];
tvgShape.cpp:    if (a) *a = pImpl->color[3];
tvgShape.cpp:    return pImpl->fill;
tvgShape.cpp:    if (!pImpl->strokeWidth(width)) return Result::FailedAllocation;
tvgShape.cpp:    if (!pImpl->stroke) return 0;
tvgShape.cpp:    return pImpl->stroke->width;
tvgShape.cpp:    if (!pImpl->strokeColor(r, g, b, a)) return Result::FailedAllocation;
tvgShape.cpp:    if (!pImpl->stroke) return Result::InsufficientCondition;
tvgShape.cpp:    if (r) *r = pImpl->stroke->color[0];
tvgShape.cpp:    if (g) *g = pImpl->stroke->color[1];
tvgShape.cpp:    if (b) *b = pImpl->stroke->color[2];
tvgShape.cpp:    if (a) *a = pImpl->stroke->color[3];
tvgShape.cpp:    if (!pImpl->strokeDash(dashPattern, cnt)) return Result::FailedAllocation;
tvgShape.cpp:    if (!pImpl->stroke) return 0;
tvgShape.cpp:    if (dashPattern) *dashPattern = pImpl->stroke->dashPattern;
tvgShape.cpp:    return pImpl->stroke->dashCnt;
tvgShape.cpp:    if (!pImpl->strokeCap(cap)) return Result::FailedAllocation;
tvgShape.cpp:    if (!pImpl->strokeJoin(join)) return Result::FailedAllocation;
tvgShape.cpp:    if (!pImpl->stroke) return StrokeCap::Square;
tvgShape.cpp:    return pImpl->stroke->cap;
tvgShape.cpp:    if (!pImpl->stroke) return StrokeJoin::Bevel;
tvgShape.cpp:    return pImpl->stroke->join;
tvgShape.cpp:    pImpl->rule = r;
tvgShape.cpp:    return pImpl->rule;
tvgShapeImpl.h:        auto dup = ret.get()->pImpl;
tvgSwCanvas.cpp:SwCanvas::SwCanvas() : Canvas(SwRenderer::gen()), pImpl(new Impl)
tvgSwCanvas.cpp:SwCanvas::SwCanvas() : Canvas(nullptr), pImpl(new Impl)
tvgSwCanvas.cpp:    delete(pImpl);
tvgSwCanvas.cpp:    auto renderer = static_cast<SwRenderer*>(Canvas::pImpl->renderer);
tvgSwCanvas.cpp:    Canvas::pImpl->needRefresh();
tvgSwCanvas.cpp://    Canvas::pImpl->refresh = true;
